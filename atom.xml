<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Yihang Ding]]></title>
  <subtitle><![CDATA[Record my thoughts]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.dyhfox.com//"/>
  <updated>2015-07-20T00:21:57.000Z</updated>
  <id>http://www.dyhfox.com//</id>
  
  <author>
    <name><![CDATA[Fox]]></name>
    <email><![CDATA[dyhfox123@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[1001. A+B Format (20)]]></title>
    <link href="http://www.dyhfox.com/2015/07/16/1001-A-B-Format-20/"/>
    <id>http://www.dyhfox.com/2015/07/16/1001-A-B-Format-20/</id>
    <published>2015-07-16T00:10:21.000Z</published>
    <updated>2015-07-20T00:21:57.000Z</updated>
    <content type="html"><![CDATA[<p>Calculate a + b and output the sum in standard format — that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p>
<p>Input</p>
<p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p>
<p>Output</p>
<p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p>
<p>Sample Input<br>-1000000 9<br>Sample Output<br>-999,991</p>
<hr>
<p>To solve this problem, We should take care following points:</p>
<ol>
<li>Nagtive numbers, should be considered.</li>
<li>Complement 0 in 0-999, both middle and after.</li>
<li>Take remainder and quotient.</li>
</ol>
<p>Below is my code: </p>
<a id="more"></a>
<pre><code><span class="comment">#include &lt;stdio.h&gt;</span>
<span class="comment">#include &lt;math.h&gt;</span>
<span class="comment">#include &lt;stdlib.h&gt;</span>
<span class="keyword">int</span> main(){
    <span class="keyword">int</span> a, b;
    scanf(<span class="string">"<span class="variable">%d</span> <span class="variable">%d</span>"</span>, &amp;a, &amp;b);
    <span class="keyword">int</span> c = a + b;
    <span class="keyword">if</span>(<span class="keyword">abs</span>(c)&lt;=<span class="number">999</span>){
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>"</span>,c);
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">abs</span>(c)&gt;<span class="number">999</span>&amp;&amp;<span class="keyword">abs</span>(c)&lt;=<span class="number">999999</span>){
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>"</span>,c/<span class="number">1000</span>);
        <span class="keyword">printf</span>(<span class="string">","</span>);
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%03d</span>"</span>,<span class="keyword">abs</span>(c<span class="variable">%1000</span>));<span class="regexp">//</span>Complement
    }
    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">abs</span>(c)&gt;=<span class="number">1000000</span>){
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%d</span>"</span>,c/<span class="number">1000000</span>);
        <span class="keyword">printf</span>(<span class="string">","</span>);
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%03d</span>"</span>,<span class="keyword">abs</span>(c<span class="variable">%1000000</span>)/<span class="number">1000</span>);
        <span class="keyword">printf</span>(<span class="string">","</span>);
        <span class="keyword">printf</span>(<span class="string">"<span class="variable">%03d</span>"</span>,<span class="keyword">abs</span>(c<span class="variable">%1000</span>));
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>Calculate a + b and output the sum in standard format — that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p>
<p>Input</p>
<p>Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space.</p>
<p>Output</p>
<p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p>
<p>Sample Input<br>-1000000 9<br>Sample Output<br>-999,991</p>
<hr>
<p>To solve this problem, We should take care following points:</p>
<ol>
<li>Nagtive numbers, should be considered.</li>
<li>Complement 0 in 0-999, both middle and after.</li>
<li>Take remainder and quotient.</li>
</ol>
<p>Below is my code: </p>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Advanced" scheme="http://www.dyhfox.com/categories/PAT-Advanced/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1010. 一元多项式求导]]></title>
    <link href="http://www.dyhfox.com/2015/07/12/1010-%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC/"/>
    <id>http://www.dyhfox.com/2015/07/12/1010-一元多项式求导/</id>
    <published>2015-07-11T22:24:32.000Z</published>
    <updated>2015-07-19T22:37:21.000Z</updated>
    <content type="html"><![CDATA[<p>设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）</p>
<p>输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<p>输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。</p>
<p>输入样例：<br>3 4 -5 2 6 1 -2 0<br>输出样例：<br>12 3 -10 1 6 0</p>
<p>这道题为了方便我用了结构体数组。特别要注意如果全是0多项式的话要输出一个 0 0<br><a id="more"></a></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">define</span> N 1000</span>
<span class="keyword">typedef</span> <span class="keyword">struct</span> poly{
    <span class="keyword">int</span> coe;
    <span class="keyword">int</span> index;
}Poly;

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    Poly a[N];
    <span class="keyword">int</span> i, tag;
    i = <span class="number">0</span>;

    <span class="comment">//input data</span>
    <span class="keyword">while</span>(i&lt;N){
        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;a[i].coe, &amp;a[i].index);
        <span class="keyword">if</span>(getchar()==<span class="string">'\n'</span>){
            <span class="keyword">break</span>;
        }
        i++;
    }

    tag = i;  <span class="comment">//store the count of array</span>
    <span class="keyword">int</span> flag = <span class="number">0</span>;
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=tag;i++){    <span class="comment">//mention that i&lt;=tag;</span>
        <span class="keyword">if</span>(a[i].index!=<span class="number">0</span>){
            a[i].coe*=a[i].index;
            a[i].index-=<span class="number">1</span>;
            <span class="keyword">if</span>(a[i].coe!=<span class="number">0</span>){
                <span class="keyword">if</span> (flag==<span class="number">1</span>){
                    <span class="built_in">printf</span>(<span class="string">" "</span>);
                    flag =<span class="number">0</span>;
                }
                <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, a[i].coe, a[i].index);
                flag =<span class="number">1</span>;
            }      
        }
    }  
    <span class="keyword">if</span>(!flag)<span class="comment">//if there is not output, then print 0 0</span>
        <span class="built_in">printf</span>(<span class="string">"0 0"</span>);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>我这个程序结构有点啰嗦，我在网上搜到别人写的一个，非常简洁，但是我没想到这点。在这贴出来</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;  </span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;  </span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  
</span>{  
    <span class="keyword">int</span> n, e, flag = <span class="number">0</span>;  
    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;e) != EOF)  
    {  
        <span class="keyword">if</span>( n*e )  
        {  
            <span class="keyword">if</span>(flag)  
                <span class="built_in">printf</span>(<span class="string">" "</span>);  
            <span class="keyword">else</span>  
                flag = <span class="number">1</span>;  
            <span class="built_in">printf</span>(<span class="string">"%d %d"</span>, n*e, e-<span class="number">1</span>);  
        }  
    }  
    <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">"0 0"</span>);  

    <span class="keyword">return</span> <span class="number">0</span>;  
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。）</p>
<p>输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p>
<p>输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。</p>
<p>输入样例：<br>3 4 -5 2 6 1 -2 0<br>输出样例：<br>12 3 -10 1 6 0</p>
<p>这道题为了方便我用了结构体数组。特别要注意如果全是0多项式的话要输出一个 0 0<br>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Basic" scheme="http://www.dyhfox.com/categories/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1011. A+B和C]]></title>
    <link href="http://www.dyhfox.com/2015/07/11/1011-A-B%E5%92%8CC/"/>
    <id>http://www.dyhfox.com/2015/07/11/1011-A-B和C/</id>
    <published>2015-07-11T00:59:30.000Z</published>
    <updated>2015-07-20T01:02:45.000Z</updated>
    <content type="html"><![CDATA[<p>给定区间[-2^31, 2^31]内的3个整数A、B和C，请判断A+B是否大于C。</p>
<p>输入格式：</p>
<p>输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。</p>
<p>输出格式：</p>
<p>对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。</p>
<p>输入样例：<br>4<br>1 2 3<br>2 3 4<br>2147483647 0 2147483646<br>0 -2147483648 -2147483647<br>输出样例：<br>Case #1: false<br>Case #2: true<br>Case #3: true<br>Case #4: false</p>
<p>这个题目非常简单，只需要定义abc为long型变量就好。因为它说的区间正好是int能表示的范围，所以如果用int变量，a+b就要超出int所能表达的范围了。<br>改成长整型就没问题了。</p>
<a id="more"></a>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">int</span> t;
    <span class="keyword">long</span> a,b,c;
    <span class="keyword">int</span> i;
    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t;i++){
        <span class="built_in">scanf</span>(<span class="string">"%ld %ld %ld"</span>,&amp;a, &amp;b, &amp;c);
        <span class="keyword">if</span>(a+b&gt;c){
            <span class="built_in">printf</span>(<span class="string">"Case #%d: true\n"</span>, i+<span class="number">1</span>);
        }
        <span class="keyword">else</span>{
            <span class="built_in">printf</span>(<span class="string">"Case #%d: false\n"</span>, i+<span class="number">1</span>);
        }
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>给定区间[-2^31, 2^31]内的3个整数A、B和C，请判断A+B是否大于C。</p>
<p>输入格式：</p>
<p>输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。</p>
<p>输出格式：</p>
<p>对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。</p>
<p>输入样例：<br>4<br>1 2 3<br>2 3 4<br>2147483647 0 2147483646<br>0 -2147483648 -2147483647<br>输出样例：<br>Case #1: false<br>Case #2: true<br>Case #3: true<br>Case #4: false</p>
<p>这个题目非常简单，只需要定义abc为long型变量就好。因为它说的区间正好是int能表示的范围，所以如果用int变量，a+b就要超出int所能表达的范围了。<br>改成长整型就没问题了。</p>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Basic" scheme="http://www.dyhfox.com/categories/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1009-说反话]]></title>
    <link href="http://www.dyhfox.com/2015/07/11/1009-%E8%AF%B4%E5%8F%8D%E8%AF%9D/"/>
    <id>http://www.dyhfox.com/2015/07/11/1009-说反话/</id>
    <published>2015-07-11T00:02:13.000Z</published>
    <updated>2015-07-20T01:59:37.000Z</updated>
    <content type="html"><![CDATA[<p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>
<p>输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。</p>
<p>输出格式：每个测试用例的输出占一行，输出倒序后的句子。</p>
<p>输入样例：<br>Hello World Here I Come<br>输出样例：<br>Come I Here World Hello</p>
<p>这道题如果说有难点，那就是字符串处理的熟悉程度比较重要了。</p>
<a id="more"></a>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">char</span> s[<span class="number">80</span>]; <span class="comment">//store string</span>
    <span class="keyword">int</span> i=<span class="number">0</span>;    <span class="comment">//initialize</span>
    <span class="keyword">char</span> c;
    <span class="keyword">int</span> j;

    <span class="comment">//input string</span>
    <span class="keyword">while</span>(<span class="number">1</span>){
        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;s[i]);
        <span class="keyword">if</span>(s[i]==<span class="string">'\n'</span>)
            <span class="keyword">break</span>;
        i++;
    }
    <span class="keyword">int</span> tag = i;    <span class="comment">//store counted number of string</span>

    <span class="comment">//print string as the requirment</span>
    <span class="keyword">for</span>(i=tag;i&gt;=<span class="number">0</span>;i--){
        <span class="keyword">if</span>(s[i]==<span class="string">' '</span>){
            <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;tag;j++){
                <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[j]);
            }
            <span class="built_in">printf</span>(<span class="string">" "</span>);
            tag=i;
        }
        <span class="keyword">if</span>(i==<span class="number">0</span>){
                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;tag;j++){
                    <span class="built_in">printf</span>(<span class="string">"%c"</span>,s[j]);  
                }
            }
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。</p>
<p>输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。</p>
<p>输出格式：每个测试用例的输出占一行，输出倒序后的句子。</p>
<p>输入样例：<br>Hello World Here I Come<br>输出样例：<br>Come I Here World Hello</p>
<p>这道题如果说有难点，那就是字符串处理的熟悉程度比较重要了。</p>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Basic" scheme="http://www.dyhfox.com/categories/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1008. 数组循环右移问题]]></title>
    <link href="http://www.dyhfox.com/2015/07/10/1008-%E6%95%B0%E7%BB%84%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98/"/>
    <id>http://www.dyhfox.com/2015/07/10/1008-数组循环右移问题/</id>
    <published>2015-07-10T12:16:12.000Z</published>
    <updated>2015-07-19T14:04:52.000Z</updated>
    <content type="html"><![CDATA[<p>一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>
<p>输入格式：每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数，之间用空格分隔。</p>
<p>输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p>
<p>输入样例：<br>6 2<br>1 2 3 4 5 6<br>输出样例：<br>5 6 1 2 3 4</p>
<p>这道题有要求只能用一个数组，所以我们应该发现这样一个窍门，只要按照格式输出就可以了，不一定非得确确实实的移动数组元素</p>
<a id="more"></a>
<p>所以就写出了下面的代码。这算是伪移动。 :)</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">int</span> n, m;
    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;n, &amp;m);
    <span class="keyword">int</span> a[n];
    <span class="keyword">int</span> i;
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){
        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);
    }
    <span class="comment">//initialize data</span>

    <span class="keyword">int</span> num =  m%n; <span class="comment">//make the m is aways smaller than the n, the result is same</span>

    <span class="comment">//print these data according the format</span>
    <span class="keyword">for</span>(i=n-num; i&lt;n; i++){
        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);
    }
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n-num;i++){
        <span class="built_in">printf</span>(<span class="string">"%d"</span>,a[i]);
        <span class="keyword">if</span>(i!=n-num-<span class="number">1</span>){
            <span class="built_in">printf</span>(<span class="string">" "</span>);
        }
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>
<p>输入格式：每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数，之间用空格分隔。</p>
<p>输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p>
<p>输入样例：<br>6 2<br>1 2 3 4 5 6<br>输出样例：<br>5 6 1 2 3 4</p>
<p>这道题有要求只能用一个数组，所以我们应该发现这样一个窍门，只要按照格式输出就可以了，不一定非得确确实实的移动数组元素</p>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Basic" scheme="http://www.dyhfox.com/categories/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1007. 素数对猜想]]></title>
    <link href="http://www.dyhfox.com/2015/07/09/1007-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"/>
    <id>http://www.dyhfox.com/2015/07/09/1007-素数对猜想/</id>
    <published>2015-07-09T12:55:52.000Z</published>
    <updated>2015-07-19T14:01:26.000Z</updated>
    <content type="html"><![CDATA[<p>让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p>
<p>现给定任意正整数N (&lt; 10^5)，请计算不超过N的满足猜想的素数对的个数。</p>
<p>输入格式：每个测试输入包含1个测试用例，给出正整数N。</p>
<p>输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。</p>
<p>输入样例：<br>20<br>输出样例：<br>4</p>
<p>这道题还是挺考验功力，因为判题系统对运行时间有要求，这个问题在边界情况计算量还是蛮大的。我改了一次才通过，想了好久才想通，问题出在is_prime函数上。我之前很随意的用了</p>
<pre><code>for<span class="comment">(i=2;i&lt;a/2;i++)</span>
</code></pre><a id="more"></a>
<p>这个语句导致我的程序运行超时，最后把a/2改成了sqrt(a)通过了。仔细想想这个运算量剩下的还是挺多的</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;math.h&gt;</span>

<span class="comment">//Judge if a number is prime</span>
<span class="function"><span class="keyword">int</span> <span class="title">is_prime</span><span class="params">(<span class="keyword">int</span> a)</span></span>{
    <span class="keyword">int</span> i;
    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;=<span class="built_in">sqrt</span>(a);i++){
        <span class="keyword">if</span>(a%i==<span class="number">0</span>){
            <span class="keyword">return</span> <span class="number">0</span>;
        }
    }
    <span class="keyword">return</span> <span class="number">1</span>;
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">int</span> n;
    <span class="keyword">int</span> cnt=<span class="number">0</span>;
    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);
    <span class="keyword">int</span> i;
    <span class="keyword">int</span> temp =<span class="number">2</span>;

    <span class="comment">//Looking for pair of prime that fulfil the requirement</span>
    <span class="keyword">for</span>(i=<span class="number">3</span>;i&lt;=n;i++){
        <span class="keyword">if</span>(is_prime(i)==<span class="number">1</span>){
            <span class="keyword">if</span>(i-temp==<span class="number">2</span>){
                cnt++;
            }
            temp=i;
        }

    }    

    <span class="comment">//Print count of the pair</span>
    <span class="built_in">printf</span>(<span class="string">"%d"</span>,cnt);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。</p>
<p>现给定任意正整数N (&lt; 10^5)，请计算不超过N的满足猜想的素数对的个数。</p>
<p>输入格式：每个测试输入包含1个测试用例，给出正整数N。</p>
<p>输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。</p>
<p>输入样例：<br>20<br>输出样例：<br>4</p>
<p>这道题还是挺考验功力，因为判题系统对运行时间有要求，这个问题在边界情况计算量还是蛮大的。我改了一次才通过，想了好久才想通，问题出在is_prime函数上。我之前很随意的用了</p>
<pre><code>for<span class="comment">(i=2;i&lt;a/2;i++)</span>
</code></pre>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Basic" scheme="http://www.dyhfox.com/categories/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1006. 换个格式输出整数]]></title>
    <link href="http://www.dyhfox.com/2015/07/08/1006-%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0/"/>
    <id>http://www.dyhfox.com/2015/07/08/1006-换个格式输出整数/</id>
    <published>2015-07-08T11:25:34.000Z</published>
    <updated>2015-07-19T13:55:59.000Z</updated>
    <content type="html"><![CDATA[<p>让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&lt;10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。</p>
<p>输入格式：每个测试输入包含1个测试用例，给出正整数n（&lt;1000）。</p>
<p>输出格式：每个测试用例的输出占一行，用规定的格式输出n。</p>
<p>输入样例1：<br>234<br>输出样例1：<br>BBSSS1234<br>输入样例2：<br>23<br>输出样例2：<br>SS123</p>
<p>这个程序最开始我想复杂了，用的字符串来解决的，写了整整四十行的代码。后来突然想明白了，用两个取余运算就可以了。因为不论几位数，取余都不会影响结果，不需要控制位数的语句。</p>
<a id="more"></a>
<p>这是修改后的代码，非常简洁，也非常好理解</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">int</span> n,i;
    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);
    <span class="keyword">int</span> b,s,g;
    b=n/<span class="number">100</span>;     <span class="comment">//百位上的数</span>
    s=n%<span class="number">100</span>/<span class="number">10</span>; <span class="comment">//十位数上的数</span>
    g=n%<span class="number">10</span>;        <span class="comment">//个位数</span>
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;b;i++){
        <span class="built_in">printf</span>(<span class="string">"B"</span>);
    }
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;s;i++){
        <span class="built_in">printf</span>(<span class="string">"S"</span>);
    }
    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=g;i++){
        <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);
    }

    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&lt;10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。</p>
<p>输入格式：每个测试输入包含1个测试用例，给出正整数n（&lt;1000）。</p>
<p>输出格式：每个测试用例的输出占一行，用规定的格式输出n。</p>
<p>输入样例1：<br>234<br>输出样例1：<br>BBSSS1234<br>输入样例2：<br>23<br>输出样例2：<br>SS123</p>
<p>这个程序最开始我想复杂了，用的字符串来解决的，写了整整四十行的代码。后来突然想明白了，用两个取余运算就可以了。因为不论几位数，取余都不会影响结果，不需要控制位数的语句。</p>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Basic" scheme="http://www.dyhfox.com/categories/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1005. 继续(3n+1)猜想]]></title>
    <link href="http://www.dyhfox.com/2015/07/07/1005-%E7%BB%A7%E7%BB%AD-3n-1-%E7%8C%9C%E6%83%B3/"/>
    <id>http://www.dyhfox.com/2015/07/07/1005-继续-3n-1-猜想/</id>
    <published>2015-07-07T12:23:46.000Z</published>
    <updated>2015-07-19T13:50:11.000Z</updated>
    <content type="html"><![CDATA[<p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p>
<p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。</p>
<p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p>
<p>输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(&lt;100)，第2行给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间用空格隔开。</p>
<p>输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。</p>
<p>输入样例：<br>6<br>3 5 6 7 8 11<br>输出样例：<br>7 6</p>
<p>这道题的描述比较拗口，其实就是找出来其他数进行卡拉兹猜想进行过程中出现的中间数，看是否包含已经给出的这几个数。最后要输出其他数进行卡拉兹猜想的中间数不包含的那些数。</p>
<a id="more"></a>
<p>我自己马虎大意，没有完全理解题意，把3<em>n+1算作一步 3\</em>n+1/2又算作一步，导致程序有一个测试点过不去。注意这两个式子是一步。如果分成两步，会多算出来一些中间数，导致某个输入样例本来是关键数结果被包含。</p>
<p>下面是我的代码，程序关系比较复杂，嵌套有些多，改天看看是否可以优化一下。</p>
<pre><code><span class="preprocessor">#include &lt;stdio.h&gt;</span>
typedef <span class="keyword">struct</span> input{
    <span class="keyword">int</span> <span class="keyword">value</span>;
    <span class="keyword">int</span> key;
}Input;
<span class="function"><span class="keyword">void</span> <span class="title">proc</span>(<span class="params">Input *p, <span class="keyword">int</span> k</span>)</span>{
    <span class="keyword">int</span> i,j;
    <span class="keyword">int</span> n;
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++){
        n=p[i].<span class="keyword">value</span>;
        <span class="keyword">if</span>(p[i].key ==<span class="number">1</span>){
            <span class="keyword">while</span>(n!=<span class="number">1</span>){
                <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>){
                    n=n/<span class="number">2</span>;
                }
                <span class="keyword">else</span>{
                    n=n*<span class="number">3</span>+<span class="number">1</span>;
                    n=n/<span class="number">2</span>;
                }
                <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;k;j++){
                    <span class="keyword">if</span>(p[j].<span class="keyword">value</span> == n){
                        p[j].key = <span class="number">0</span>;
                    }
                }
            }
        }
    }
}
<span class="function"><span class="keyword">void</span> <span class="title">print</span>(<span class="params">Input *p, <span class="keyword">int</span> k</span>)</span>{
    <span class="keyword">int</span> i, j;
    <span class="keyword">int</span> temp;
    <span class="keyword">int</span> cnt=<span class="number">0</span>;
    <span class="keyword">int</span> count=<span class="number">0</span>;
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++){
        <span class="keyword">if</span>(p[i].key ==<span class="number">1</span>){
            count++;
        }
    }
    <span class="comment">//sort</span>
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++){
        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;k;j++){
            <span class="keyword">if</span>(p[i].key==<span class="number">1</span>&amp;&amp;p[j].key==<span class="number">1</span>){
                <span class="keyword">if</span>(p[i].<span class="keyword">value</span>&lt;p[j].<span class="keyword">value</span>){
                    temp = p[i].<span class="keyword">value</span>;
                    p[i].<span class="keyword">value</span> = p[j].<span class="keyword">value</span>;
                    p[j].<span class="keyword">value</span> = temp;
                }
            }
        }
    }
    <span class="comment">//print</span>
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++){
        <span class="keyword">if</span>(p[i].key ==<span class="number">1</span>){

            printf(<span class="string">"%d"</span>, p[i].<span class="keyword">value</span>);
            cnt++;
            <span class="keyword">if</span>(cnt!=count){
                printf(<span class="string">" "</span>);
            }

        }
    }
}
<span class="function"><span class="keyword">int</span> <span class="title">main</span>(<span class="params"></span>)</span>{
    <span class="keyword">int</span> k,i;
    scanf(<span class="string">"%d"</span>,&amp;k);
    Input a[k];
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;k;i++){
        scanf(<span class="string">"%d"</span>,&amp;a[i].<span class="keyword">value</span>);
        a[i].key = <span class="number">1</span>;
    }
    proc(a,k);
    print(a,k);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p>
<p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。</p>
<p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p>
<p>输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(&lt;100)，第2行给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间用空格隔开。</p>
<p>输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。</p>
<p>输入样例：<br>6<br>3 5 6 7 8 11<br>输出样例：<br>7 6</p>
<p>这道题的描述比较拗口，其实就是找出来其他数进行卡拉兹猜想进行过程中出现的中间数，看是否包含已经给出的这几个数。最后要输出其他数进行卡拉兹猜想的中间数不包含的那些数。</p>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Basic" scheme="http://www.dyhfox.com/categories/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1004. 成绩排名 (20)]]></title>
    <link href="http://www.dyhfox.com/2015/07/06/1004-%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D-20/"/>
    <id>http://www.dyhfox.com/2015/07/06/1004-成绩排名-20/</id>
    <published>2015-07-06T13:23:15.000Z</published>
    <updated>2015-07-19T13:41:21.000Z</updated>
    <content type="html"><![CDATA[<p>读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>
<p>输入格式：每个测试输入包含1个测试用例，格式为</p>
<p>  第1行：正整数n<br>  第2行：第1个学生的姓名 学号 成绩<br>  第3行：第2个学生的姓名 学号 成绩<br>  … … …<br>  第n+1行：第n个学生的姓名 学号 成绩<br>其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。<br>输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。</p>
<p>输入样例：<br>3<br>Joe Math990112 89<br>Mike CS991301 100<br>Mary EE990830 95<br>输出样例：<br>Mike CS991301<br>Joe Math990112</p>
<p>这道题很简单，但是需要用到结构体数组，用来存储类型不同类型的数据，这样会方便的多。<br><a id="more"></a></p>
<pre><code>   <span class="comment">/*
Input is a list of students, every student have a     neme, an id, and a score. 
Print the name and id of highest and lowest student.
*/</span>

<span class="preprocessor">#<span class="keyword">include</span> "stdio.h"</span>
<span class="preprocessor">#<span class="keyword">include</span> "stdlib.h"</span>
<span class="preprocessor">#<span class="keyword">include</span> "string.h"</span>

<span class="keyword">typedef</span> <span class="keyword">struct</span> stu{
<span class="comment">//Mention it that the puzzle is required 10 long string, plus '\0', we should create name[11], id[11]</span>
<span class="keyword">char</span> name[<span class="number">11</span>];
<span class="keyword">char</span> id[<span class="number">11</span>];
<span class="keyword">int</span> score;
}Student;

<span class="function"><span class="keyword">void</span> <span class="title">sorted_print</span><span class="params">(Student *p,<span class="keyword">int</span> n)</span></span>{
    <span class="keyword">int</span> min;
    <span class="keyword">int</span> max =min= p[<span class="number">0</span>].score;
    <span class="keyword">int</span> i;
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){
        <span class="keyword">if</span> (max&lt;p[i].score){
            max = p[i].score;
        }
    }
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){
        <span class="keyword">if</span> (min&gt;p[i].score){
            min = p[i].score;
        }
    }
    i=<span class="number">0</span>;<span class="comment">//Reinitialize i = 0;</span>
    <span class="keyword">int</span> flagmax,flagmin;
    <span class="keyword">while</span>(i&lt;n){
        <span class="keyword">if</span>(max==p[i].score){
            flagmax = i;
        }
        <span class="keyword">if</span>(min==p[i].score){
            flagmin = i;

        }
        i++;
    }
    <span class="built_in">printf</span>(<span class="string">"%s"</span>,p[flagmax].name );
    <span class="built_in">printf</span>(<span class="string">" "</span>);
    <span class="built_in">printf</span>(<span class="string">"%s"</span>,p[flagmax].id);
    <span class="built_in">printf</span>(<span class="string">"\n"</span>);

    <span class="built_in">printf</span>(<span class="string">"%s"</span>,p[flagmin].name );
    <span class="built_in">printf</span>(<span class="string">" "</span>);
    <span class="built_in">printf</span>(<span class="string">"%s"</span>,p[flagmin].id);
    <span class="built_in">printf</span>(<span class="string">"\n"</span>);
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">int</span> n;
    <span class="keyword">int</span> i;
    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);
    Student stu[n];
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){
        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;stu[i].name);
        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;stu[i].id);
        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;stu[i].score);        
    }
    sorted_print(stu,n);
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。</p>
<p>输入格式：每个测试输入包含1个测试用例，格式为</p>
<p>  第1行：正整数n<br>  第2行：第1个学生的姓名 学号 成绩<br>  第3行：第2个学生的姓名 学号 成绩<br>  … … …<br>  第n+1行：第n个学生的姓名 学号 成绩<br>其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。<br>输出格式：对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。</p>
<p>输入样例：<br>3<br>Joe Math990112 89<br>Mike CS991301 100<br>Mary EE990830 95<br>输出样例：<br>Mike CS991301<br>Joe Math990112</p>
<p>这道题很简单，但是需要用到结构体数组，用来存储类型不同类型的数据，这样会方便的多。<br>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Basic" scheme="http://www.dyhfox.com/categories/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1003. 我要通过！(20)]]></title>
    <link href="http://www.dyhfox.com/2015/07/05/1003-%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81-20/"/>
    <id>http://www.dyhfox.com/2015/07/05/1003-我要通过！-20/</id>
    <published>2015-07-04T18:41:59.000Z</published>
    <updated>2015-07-18T19:03:38.000Z</updated>
    <content type="html"><![CDATA[<p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。</p>
<p>得到“答案正确”的条件是：</p>
<ol>
<li>字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；</li>
<li>任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；</li>
<li>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。</li>
</ol>
<p>现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。<br>输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。</p>
<p>输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。</p>
<p>输入样例：<br>8<br>PAT<br>PAAT<br>AAPATAA<br>AAPAATAAAA<br>xPATx<br>PT<br>Whatever<br>APAAATAA<br>输出样例：<br>YES<br>YES<br>YES<br>YES<br>NO<br>NO<br>NO<br>NO<br><a id="more"></a></p>
<p><em>这个程序题目的关键在于发现这样的一个规律：P和T之前的A的个数乘以中间的A的个数等于T之后A的个数</em><br>发现这个规律就好写多了。我也是看了好久才发现-_-#</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;stdlib.h&gt;</span>
<span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span>
<span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span> *p)</span></span>{                <span class="comment">//传入地址操作字符串本身</span>
    <span class="keyword">int</span> num1=<span class="number">0</span>,num2=<span class="number">0</span>,num3=<span class="number">0</span>;
    <span class="keyword">int</span> flag=<span class="number">0</span>;
    <span class="keyword">int</span> flagp=<span class="number">0</span>,flaga=<span class="number">0</span>,flagt=<span class="number">0</span>;
    <span class="keyword">int</span> i=<span class="number">0</span>;
    <span class="keyword">int</span> nump=<span class="number">0</span>;
    <span class="keyword">int</span> numt=<span class="number">0</span>;
    <span class="keyword">char</span> q[] = <span class="string">"PAT"</span>;
    <span class="comment">//考虑各种情况下的输出</span>
    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(p, q) == <span class="number">0</span>){
        <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);
        <span class="keyword">return</span> <span class="number">0</span>;
    }
    <span class="keyword">else</span>{
        <span class="keyword">while</span>(p[i]!=<span class="string">'\0'</span>){
            <span class="keyword">if</span>(p[i]==<span class="string">'P'</span>){
                flagp=<span class="number">1</span>;
                nump++;
            }
            <span class="keyword">if</span>(p[i]==<span class="string">'A'</span>){
                flaga=<span class="number">1</span>;
            }
            <span class="keyword">if</span>(p[i]==<span class="string">'T'</span>){
                flagt=<span class="number">1</span>;
                numt++;
            }
            <span class="keyword">if</span>(p[i]!=<span class="string">'P'</span>&amp;&amp;p[i]!=<span class="string">'A'</span>&amp;&amp;p[i]!=<span class="string">'T'</span>){
                <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);
                <span class="keyword">return</span> <span class="number">0</span>;    
               }
            <span class="keyword">if</span>(p[i]==<span class="string">'P'</span>)
                flag=<span class="number">1</span>;
            <span class="keyword">if</span>(p[i]==<span class="string">'T'</span>)
                flag=<span class="number">2</span>;
            <span class="keyword">if</span>(p[i]==<span class="string">'A'</span>&amp;&amp;flag==<span class="number">0</span>){
                num1++;
            }
            <span class="keyword">if</span>(p[i]==<span class="string">'A'</span>&amp;&amp;flag==<span class="number">1</span>){
                num2++;
            }
            <span class="keyword">if</span>(p[i]==<span class="string">'A'</span>&amp;&amp;flag==<span class="number">2</span>){
                num3++;
            }
            i++;
           }
        <span class="keyword">if</span>(num1*num2==num3&amp;&amp;flagp==<span class="number">1</span>&amp;&amp;flaga==<span class="number">1</span>&amp;&amp;flagt==<span class="number">1</span>&amp;&amp;nump==<span class="number">1</span>&amp;&amp;numt==<span class="number">1</span>){
            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);
               <span class="keyword">return</span> <span class="number">0</span>;
        }
           <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);
    }
       <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{

    <span class="keyword">int</span> n;
    <span class="keyword">int</span> flag;
    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);
    <span class="keyword">char</span> a[<span class="number">10</span>][<span class="number">100</span>];
    <span class="keyword">int</span> i, j;
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){
        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a[i]);
    }
    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++){
        print(a[i]);
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。</p>
<p>得到“答案正确”的条件是：</p>
<ol>
<li>字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；</li>
<li>任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；</li>
<li>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。</li>
</ol>
<p>现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。<br>输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。</p>
<p>输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。</p>
<p>输入样例：<br>8<br>PAT<br>PAAT<br>AAPATAA<br>AAPAATAAAA<br>xPATx<br>PT<br>Whatever<br>APAAATAA<br>输出样例：<br>YES<br>YES<br>YES<br>YES<br>NO<br>NO<br>NO<br>NO<br>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Basic" scheme="http://www.dyhfox.com/categories/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1002. 写出这个数 (20)]]></title>
    <link href="http://www.dyhfox.com/2015/07/03/1002-%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0-20/"/>
    <id>http://www.dyhfox.com/2015/07/03/1002-写出这个数-20/</id>
    <published>2015-07-02T16:04:49.000Z</published>
    <updated>2015-07-18T19:03:28.000Z</updated>
    <content type="html"><![CDATA[<p>读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>
<p>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10100。</p>
<p>输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。</p>
<p>输入样例：<br>1234567890987654321123456789<br>输出样例：<br>yi san wu<br><a id="more"></a></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>

<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span>{
    <span class="keyword">switch</span>(a){
        <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">"ling"</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">"yi"</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">"er"</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">3</span>: <span class="built_in">printf</span>(<span class="string">"san"</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">4</span>: <span class="built_in">printf</span>(<span class="string">"si"</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">5</span>: <span class="built_in">printf</span>(<span class="string">"wu"</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">6</span>: <span class="built_in">printf</span>(<span class="string">"liu"</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">7</span>: <span class="built_in">printf</span>(<span class="string">"qi"</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">8</span>: <span class="built_in">printf</span>(<span class="string">"ba"</span>);
            <span class="keyword">break</span>;
        <span class="keyword">case</span> <span class="number">9</span>: <span class="built_in">printf</span>(<span class="string">"jiu"</span>);
            <span class="keyword">break</span>;
           <span class="keyword">default</span>:
                 <span class="keyword">break</span>;
    }
}
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">char</span> c[<span class="number">101</span>];
    <span class="keyword">int</span> j,sum=<span class="number">0</span>;
    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,c);
    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">101</span>;j++){
        <span class="keyword">if</span>(c[j]==<span class="string">'\0'</span>)
            <span class="keyword">break</span>;
        sum+=c[j]-<span class="string">'0'</span>;
    }
    <span class="keyword">int</span> a[<span class="number">100</span>];
    <span class="keyword">int</span> cnt = <span class="number">0</span>;
    <span class="keyword">int</span> i;
    <span class="keyword">while</span>(sum/<span class="number">10</span> != <span class="number">0</span>){
        a[cnt] = sum % <span class="number">10</span>;
        sum = sum/<span class="number">10</span>;
        cnt++;
        }
       a[cnt] = sum;
    <span class="keyword">for</span>(i=cnt; i&gt;=<span class="number">0</span>; i--){
        print(a[i]);
        <span class="keyword">if</span>(i!=<span class="number">0</span>){
            <span class="built_in">printf</span>(<span class="string">" "</span>);
        }
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。</p>
<p>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10100。</p>
<p>输出格式：在一行内输出n的各位数字之和的每一位，拼音数字间有1 空格，但一行中最后一个拼音数字后没有空格。</p>
<p>输入样例：<br>1234567890987654321123456789<br>输出样例：<br>yi san wu<br>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Basic" scheme="http://www.dyhfox.com/categories/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[1001. 害死人不偿命的(3n+1)猜想 (15)]]></title>
    <link href="http://www.dyhfox.com/2015/07/01/1001-%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84-3n-1-%E7%8C%9C%E6%83%B3-15/"/>
    <id>http://www.dyhfox.com/2015/07/01/1001-害死人不偿命的-3n-1-猜想-15/</id>
    <published>2015-07-01T15:53:48.000Z</published>
    <updated>2015-07-18T19:03:11.000Z</updated>
    <content type="html"><![CDATA[<p>卡拉兹(Callatz)猜想：</p>
<p>对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p>
<p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？</p>
<p>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。</p>
<p>输出格式：输出从n计算到1需要的步数。</p>
<p>输入样例：<br>3<br>输出样例：<br>5<br><a id="more"></a></p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> &lt;stdio.h&gt;</span>

<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{
    <span class="keyword">int</span> cnt=<span class="number">0</span>; <span class="comment">// Counter</span>
    <span class="keyword">int</span> n;
    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);

    <span class="comment">// Process Clalatz</span>
    <span class="keyword">while</span>(n!=<span class="number">1</span>){
        n=n%<span class="number">2</span> ? (<span class="number">3</span>*n+<span class="number">1</span>)/<span class="number">2</span> : n/<span class="number">2</span>;
        cnt++;
    }
    <span class="built_in">printf</span>(<span class="string">"%d"</span>,cnt);
    reuturn <span class="number">0</span>;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>卡拉兹(Callatz)猜想：</p>
<p>对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……</p>
<p>我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？</p>
<p>输入格式：每个测试输入包含1个测试用例，即给出自然数n的值。</p>
<p>输出格式：输出从n计算到1需要的步数。</p>
<p>输入样例：<br>3<br>输出样例：<br>5<br>]]>
    
    </summary>
    
      <category term="Coding" scheme="http://www.dyhfox.com/tags/Coding/"/>
    
      <category term="PAT Basic" scheme="http://www.dyhfox.com/categories/PAT-Basic/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[第一篇]]></title>
    <link href="http://www.dyhfox.com/2015/07/01/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://www.dyhfox.com/2015/07/01/第一篇/</id>
    <published>2015-07-01T04:44:34.000Z</published>
    <updated>2015-07-20T01:55:06.000Z</updated>
    <content type="html"><![CDATA[<p><img src="/images/IMG_2097.jpg" style="width: 700px;"></p>
<p>鼓捣了两天，换了n个网页生成工具，终于确定下来选了hexo。虽然这个仍然是很简陋的静态页面，但是好歹是有个地方供我记录下生活了。</p>
<p>实习三个半月，终于体会了以前嗤之以鼻的大人说的话：“当学生最舒服了”。回想起来在学校的时候有什么不如意愁得脑袋发胀，跟真正走上社会的愁比起来简直幸福的掉泪。人啊，总会经历了才会明白。看着刚刚拿到的毕业证学位证，恍然发现自己再也不是学生了，再也没有寒暑假，没有随心所欲，没有早起不想起来就逃课的机会了。再也不能把自己当孩子了。仿佛一下子所有的责任都有了。</p>
<p>这三个半月想了很多。目前的工作也并不喜欢，但又无可奈何，因为自己的能力并不足以有底气辞职再去找工作。但有一点是好的，就是我现在终于弄明白该干什么该怎么干了。开这个博客也正是想有一个新的开始，记录我接下来的生活工作和学习。同时也希望能够敦促我坚持下去，如果哪天泄气了，上来看看我写的字，码的代码。重新鼓起勇气去向前走。自勉！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="/images/IMG_2097.jpg" style="width: 700px;"></p>
<p>鼓捣了两天，换了n个网页生成工具，终于确定下来选了hexo。虽然这个仍然是很简陋的静态页面，但是好歹是有个地方供我记录下生活了。</p>
<p>实习三]]>
    </summary>
    
      <category term="日常" scheme="http://www.dyhfox.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="日常" scheme="http://www.dyhfox.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>